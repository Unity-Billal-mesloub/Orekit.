<!--- Copyright 2022-2025 Thales Alenia Space
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

# Upgrading from Orekit 13.X to Orekit 14.0

Version 14.0 of Orekit introduced some incompatible API changes with respect
to versions 13.x. These changes are summarized in the following table. The next
paragraphs give hints about how users should change application source code to
adapt to this new version.

| change                                                                                                                                                                 | related issues                                                                                                                           |
|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------|
| [custom GNSS time systems](#Custom_GNSS_Time_Systems)                                                                                                                  | [issue 1775](https://gitlab.orekit.org/orekit/orekit/-/issues/1775)                                                                      |
| [revamping of rinex files](#Revamping_of_Rinex_Files)                                                                                                                  | [issue 1689](https://gitlab.orekit.org/orekit/orekit/-/issues/1689), [issue 1776](https://gitlab.orekit.org/orekit/orekit/-/issues/1776) |
| [fast number formatting for scientific notation](#Fast_Number_Formatting_for_Scientific_Notation)                                                                      | [issue 1780](https://gitlab.orekit.org/orekit/orekit/-/issues/1780)                                                                      |
| [created clocks package](#Created_Clocks_Package)                                                                                                                      | [issue 1802](https://gitlab.orekit.org/orekit/orekit/-/issues/1802)                                                                      |
| [add abstract class for detectors based on BodyShape](#Add_abstract_class_for_detectors_based_on_BodyShape)                                                            | [issue 1244](https://gitlab.orekit.org/orekit/orekit/-/issues/1244)                                                                      |
| [move (Field)OrbitBlender to propagation package](#Move_orbit_blender_to_propagation_package)                                                                          | [issue 1806](https://gitlab.orekit.org/orekit/orekit/-/issues/1806)                                                                      |
| [create cr3bp subpackage inside orbit](#Create_cr3bp_subpackage_inside_orbit)                                                                                          | [issue 1807](https://gitlab.orekit.org/orekit/orekit/-/issues/1807)                                                                      |
| [use String in API for GNSS observation types](#Use_String_in_API_for_GNSS_Observation_Types)                                                                          | [issue 1810](https://gitlab.orekit.org/orekit/orekit/-/issues/1810)                                                                      |
| [create covariance subpackage inside propagation](#Create_covariance_subpackage_inside_propagation)                                                                    | [issue 1789](https://gitlab.orekit.org/orekit/orekit/-/issues/1789)                                                                      |
| [remove field parameter of FieldDSSTPropagator and FieldNumericalPropagator](#Remove field parameter of FieldDSSTPropagator and FieldNumericalPropagator)              | [issue 1809](https://gitlab.orekit.org/orekit/orekit/-/issues/1809)                                                                      |
| [refactored (Field)AbsolutePVCoordinates and deleted (Field)ShiftingPVCoordinatesProvider](#Refactored AbsolutePVCoordiates and deleted ShiftingPVCoordinatesProvider) | [issue 1830](https://gitlab.orekit.org/orekit/orekit/-/issues/1830)                                                                      |
| [introduced dedicated classes for signal travel time](#Introduced_dedicated_classes_for_signal_travel_time)                                                            | [issue 1835](https://gitlab.orekit.org/orekit/orekit/-/issues/1835)                                                                      |
| [removed ConstantPVCoordinatesProvider](#Removed_ConstantPVCoordinatesProvider)                                                                                        | [issue 1840](https://gitlab.orekit.org/orekit/orekit/-/issues/1840)                                                                      |
| [refactored counting handlrs](#Refactored_counting_handlers)                                                                                                           | [issue 1842](https://gitlab.orekit.org/orekit/orekit/-/issues/1842)                                                                      |
| [updated Lambert solver](#Updated_Lambert_solver)                                                                                                                      | [issue 1781](https://gitlab.orekit.org/orekit/orekit/-/issues/1781)                                                                      |
| [revamped GNSSPropagatorBuilder](#Revamped_GNSSPropagatorBuilder)                                                                                | [issue 1850](https://gitlab.orekit.org/orekit/orekit/-/issues/1850)                                                                      |


## Custom GNSS Time Systems

### overview of the change

In the 13.X series, `TimeSystem` was an enumerate, and therefore included only
a limited set of values, preventing it to be used for custom GNSS systems that
are not yet officially recognized by IGS. `TimeSystem` has therefore been
changed to an interface to allow for custom implementations, and a new
`PredefinedTimeSystem` enumerate has been set up containing the official
implementations.

### how to adapt existing source code

If users need to initialize a value from the predefined lists (say `GALILEO` time
system), then they should use `PredefinedTimeSystem.GALILEO` enumerate constant.
If they just need to pass around a time system that has already been created (say
parsed from some file or created from scratch by a simulator), then they should
rather use the `TimeSystem` type, as it is more general and can be used for both
predefined and custom time systems.

## Revamping of Rinex Files

### overview of the change

In the 13.X series, `RinexClock` was a flat structure that was
inconsistent with `RinexObservation` and `RinexNavigation` and had no
associated writer. The leap seconds setting in all Rinex files was
also inconsistent (in fact, it is inconsistent in the standard
themselves as LEAP SECONDS in clock file does not have the same
meaning in observation and navigation files…).

Support for version 4.02 of Rinex observation and navigation files was
added in 13.X series, but only partially. A few messages could not be parsed
(NavIC ionosphere messages type L1NV, subtypes KLO and NEQN, GLONASS ionosphere
messages LXOC). There was no support for writing Rinex navigation files.

Inconsistencies in clock files and support for missing navigation messages
have been resolved by revamping the classes hierarchy, `RinexClockWriter`
`RinexNavigationWriter` and many support container classes have been created.
Note that the GLONASS L1OC and L3OC CDMA navigation messages are still not
supported (they are silently ignored when parsing navigation files).

The change mainly implies several getters that were directly in `RinexClock`
or in some navigation messages have been moved around. A new `RinexClockHeader`
has been added, and the clock comments are now regular instances of `RinexComment`
that can be accessed individually instead of being a single concatenated string.
The getters and setters for leap seconds now explicitly state whereas they
correspond to the separation between UTC and TAI or to the separation between
UTC and GNSS (really GPS). A new `IonosphereAij` intermediate container has
been added to `IonosphereNequickGMessage` (and reused in the new
`IonosphereNavICNeQuickNMessage`). In anticipation of future support for GLONASS
L1OC and L3OC CDMA navigation messages, the `GLONASSNavigationMessage` has been
renamed `GLONASSFdmaNavigationMessage`.

The change also implied that the navigation messages in the
`org.propagation.analytical.gnss.data` packages now require a message type at
construction time (`LNAV`, `CNAV`, `C2NV`…).

### how to adapt existing source code

Users should access the data from the header by first retrieving the
header using `rinexClock.getHeader()`, and then access the relevant
data (using for example `rinexClockHeader.getReceivers()`). The value
returned by `rinexClock.getComments()` is now a list of
`RinexComment`, each instance containing the line number and the
text. The `{get|set}LeapSeconds` and `{get|set}NumberOfLeapSeconds`
methods have been replaced by `{get|set}LeapSecondsTAI` and
`{get|set}LeapSecondsGNSS`. Access to the aᵢⱼ coefficients from
`IonosphereNequickGMessage` now uses an intermediate `getAij` method
to retrieve the intermediate container. References to the
`GLONASSNavigationMessage` name should be changed to the new name
`GLONASSFdmaNavigationMessage`.

If navigation messages were built from scratch (instead of being parsed
from Rinex navigation files), then the message type should be added
to the constructor call.

## Fast Number Formatting for Scientific Notation

### overview of the change

In the 13.X series, the `FastDoubleFormatter` was added, alongside
`FastLongFormatter`, for speeding up writing of large files. The double
formatter could only support decimal format, but not scientific format,
which is used for example in Rinex clock and Rinex navigation files.
This limitation has been lifted in 14.0 by adding a new `FastScientificFormatter`.

This change implied changing the existing `FastDoubleFormatter` to an abstract
class which cannot be instanciated anymore, and introducing a `FastDecimalFormatter`
class. Both `FastDecimalFormatter` and `FastScientificFormatter` extend the
`FastDoubleFormatter` abstract class and can be instanciated.

### how to adapt existing source code

Users who built `FastDecimalFormatter` instances should now build
`FastDecimalFormatter` instances. Users who only used already built instances
can keep their variables declared as `FastDoubleFormatter` instances.

## Created Clocks Package

### overview of the change

In the 13.X series, the most classes related to clock models were in the
`org.orekit.time` package. Two classes related to quadratic models were
in the `org.orekit.estimation.measurements` package.

As more and more models are added, these became cumbersome, so a dedicated package
`org.orekit.time.clock` has been created. The existing classes were moved there
and new models added in 14.0 were created there too.

### how to adapt existing source code

Users of clock models and clock offsets just need to update their import statements
to get the class from their new package.

## Add abstract class for detectors based on BodyShape

### overview of the change

There was some code duplication and inconsistencies in naming between the following classes:
`(Field)AltitudeDetector`, `(Field)LongitudeCrossingDetector`, `(Field)LongitudeRangeCrossingDetector`, 
`(Field)LongitudeExtremumDetector`, `(Field)LatitudeCrossingDetector`, `(Field)LatitudeRangeCrossingDetector`,
`(Field)LatitudeExtremumDetector`.

An abstract class has been introduced for the standard detectors and the Field ones.

### how to adapt existing source code

The consequence is that the getter is now called `getBodyShape` and returns a `BodyShape.`
Please change your calls consequently.


## Move (Field)OrbitBlender to propagation package

### overview of the change

`OrbitBlender` and `(Field)OrbitBlender` depend on classes inside propagation.
They have been moved to this package.

### how to adapt existing source code

Change the imports by replacing "orbit" with "propagation".

## Create cr3bp subpackage inside orbit

### overview of the change

The package orbit had classes related to the third-body problem with dependencies to the propagation package.
For a cleaner architecture, they have been moved to a new subpackage, called cr3bp. 
This mirrors what is already done inside propagation.

### how to adapt existing source code

Change the imports by replacing "orbit" with "orbit.cr3bp" for the following classes:
`LibrationOrbit`, `LibrationOrbitFamily`, `LibrationOrbitType`, `LyapunovOrbit`, `RichardsonExpansion`,
`CR3BPDifferentialCorrection`, `HaloOrbit`

## Use String in API for GNSS Observation Types

### overview of the change

Since 13.0, `ObservationType` was an interface and `PredefinedObservationType` is an enumerate that provided
official Rinex types. This architecture allowed users to implement their own `CustomObservationType` for
upcoming missions, using a custom `typeBuilder` when parsing Rinex files. Such missions would typically reuse
existing names like `C1C` or `L1C` but with different supported `SatelliteSystem` not yet included in Rinex
standards.

There were several places in Orekit (dual frequency smoother, single frequency smoother, Sinex bias,
Rinex observation header,…) where `ObservationType` was used as a key in a `Map` or as an element in
a `List`. This prevented mixing predefined types with custom types, and this prevented searching for
elements in the maps since one cannot override the `equals` method in enumerate to for example just
compare the name of the observable. A more generic way would be to use only the name (`C1C`, `L1C`…)
in these containers, and build the real `ObservationType` (either predefined ones or custome ones) by applying
the `typeBuilder` only much later in the data flow.

### how to adapt existing source code

In many constructors, methods and containers, types have been changed from `ObservationType` to `String`.
Users who called these constructors or methods with an `ObservationType type` could just use
`type.getName()` instead to use the name of the observation type.
Users who retrieved `ObservationType` for containers (like for example `RinexObservationHeader.getNbObsPerSat()`
or `DifferentialSignalBias.getAvailableObservationPairs()`) should adjust the type of the container.
Note that the `ObservationData` that is retrieved when parsing the data part of a Rinex observation file
(i.e. *not* the header) are still full-blown `ObservationType`, that were built at parse time by applying
the `typeBuilder` to the `String` name (this is typically how custom observation types are parsed in custom
missions).
The `SinexBiasParser` does not need a `typeBuilder` anymore to be built, this parameter can just be
removed from users calls.

## Create covariance subpackage inside propagation

### overview of the change

Covariance-related code has been growing recently, but still seated at the root of propagation. 
It now has its own subpackage.

### how to adapt existing source code

Change the imports by replacing "propagation" with "propagation.covariance" for 
 `LinearKeplerianCovarianceMapper`, `LinearKeplerianCovarianceHandler`, `AbstractStateCovarianceInterpolator`,
`FieldStateCovariance` and all the `StateCovariance[...]` classes.

## Remove field parameter of FieldDSSTPropagator and FieldNumericalPropagator

### overview of the change

The `field` parameter of `FieldDSSTPropagator` and `FieldNumericalPropagator` has been removed. This parameter
was useless since the `field` is accessible from the provided `integrator`.

### how to adapt existing source code

Simply remove the first argument that was used with the constructors.

## Refactored AbsolutePVCoordinates and deleted ShiftingPVCoordinatesProvider

### overview of the change

The classes `AbsolutePVCoordinates` and `ShifingPVCoordinatesProvider` (as well as their Field equivalent) were pretty much duplicates. 
The former inherited from `PVCoordinates` (polymorphism) and the latter used it as attribute (class composition).
Only `(Field)AbsolutePVCoordinates` has been kept, but switching to composition. 
This allowed to remove a lot of code duplication with `(Field)Orbit`. 
After all, `AbsolutePVCoordinates` was originally introduced as an alternative coordinates system not presupposing to be in a two-body problem.

### how to adapt existing source code

It is not possible to cast `AbsolutePVCoordinates` as `PVCoordinates` anymore, you need to call the getter first. 
Most methods have been preserved. For the ones that have not (like `toDerivativeStructureVector`), call `getPVCoordinates` first.

## Introduced dedicated classes for signal travel time

### overview of the change

The methods for signal time travel were all static in `AbstractMeasurement`. They have been moved to dedicated classes.

### how to adapt existing source code

Instead of calling `signalTimeOfFlightAdjustableEmitter`, instantiate `SignalTravelTimeAdjustableEmitter` and call `compute`.
The same applies for the adjustable emitter.


## Removed ConstantPVCoordinatesProvider

### overview of the change

The class `ConstantPVCoordinatesProvider` has been removed as it had no `Field` in it.
Now, `GeodeticExtendedPositionProvider` covers both needs for Earth-fixed frames. For inertial ones, `(Field)AbsolutePVCoordinates` can be used.

### how to adapt existing source code

If your frame is Earth-fixed, you can switch to `GeodeticExtendedPositionProvider` that will also work with `Field`.
If it is inertial, you can call `new AbsolutePVCoordinates(frame, AbsoluteDate.ARBITRARY_EPOCH, new PVCoordinates(position))`.

## Refactored counting handlers

### overview of the change

The class `CountAndContinue` is now standalone, with immutable `Action`. Also, its count cannot be reset.
For more flexible options, `CountingHandler` is not abstract anymore and can be used readily, 
counting all by default and returning a custom `Action`.

### how to adapt existing source code

If you want to reset the count whilst always returning `CONTINUE`, you can use `(Field)CountingHandler`. 
Otherwise, you can stick to `(Field)CountAndContinue`.

## Updated Lambert solver

### overview of the change

`LambertSolver` has been updated to use a more recent algorithm based on Dario Izzo's solver and Gim Der's work. 
The solver can now find all possible solutions for a given problem set-up up the maximum number of revolutions.
Solutions are now returned as objects of class `LambertSolution`, with the following fields:
- `nRev`: the number of complete revolutions completed for this solution. Accessible via `getNRev()`
- `pathType`: the type of path followed for this solution (low path, high path or minimum energy path; possible values are
              defined in enumerate `LambertPathType`). Accessible via `getPathType()`
- `orbitType`: the type of orbit geometry for this solution (elliptic, parabolic or hyperbolic; possible values are
               defined in enumerate `LambertOrbitType`). Accessible via `getOrbitType()`
- `boundaryConditions`: an object of class `LambertBoundaryConditions` that contains the boundary conditions for the
                        problem setup used to compute this solution. Accessible via `getBoundaryConditions()`
- `boundaryVelocities`: an object of class `LambertBoundaryVelocities` that contains the initial and final velocities
                        corresponding to this solution. Accessible via `getBoundaryVelocities()`
Note that method `solve` from a `LambertSolver` still receives as input `posigrade`, a flag indicating if the transfer 
should be posigrade or retrograde.
Additionally, the method can be called with or without specifying `nRev`, the number of complete revolutions that should
be completed during the transfer:
- If not specified, the solver will find all possible solutions from 0 complete revolutions
  up to the maximum number of revolutions. This results in a total of `2 * (nRevMax + 1)` possible solutions 
  (1 for 0 complete revolutions, and 2 for each revolution number; two such sets of solutions, of posigrade and retrograde
  transfers, can be found)
- If specified, the solver will find only the solutions for the given number of complete revolutions, as long as this is below
  the maximum possible number of revolutions. This results in either 1 or 2 possible solutions (1 for 0 complete revolutions, 
  and 2 for each revolution number; one for posigrade and one for retrograde transfers)
For consistency, regardless of how the method is called, the returned solutions will always be a `List<LambertSolution>`.
It shoud also be noted that now `LambertSolver` uses internally a Householder solver, and therefore the maximum number of
iterations, atol and rtol can be chosen when instantiating a `LambertSolver`. Alternatively, a constructor receiving only
`mu` is available that uses default values for these (2000 iterations, 1.0e-5 for atol and 1.0e-7 for rtol). This also ensures
backward compatibility with existing code.

### how to adapt existing source code

Existing calls to method `solve` are still accepted since they use the same signature as the current call providing a specific
value for `nRev`. However, since now method `solve` always returns a `List<LambertSolution>`, you will need to update the code
to take this into account. The previous Lambert solver always returned the low path solution. In the current implementation,
for multi-revolution transfers, the low-path solution will always be returned as the first element of the list. Therefore, to
adapt existing code, you can retrieve the first element of the returned list.

## Revamped GNSSPropagatorBuilder

### overview of the change

As of 13.X, `GNSSPropagatorBuilder` was a standalone class, not related at all with `PropagatorBuilder`
and with a different API. This prevented using such builders in orbit determination, as for
example `BatchLSModel` requires an array of `PropagatorBuilder` instances. The class also assumed some
defaults for inertial and body fixed frames that were confusing (for example an ITRF frame without tidal
effect, which is not compatible with geodetic precision needs).

The `GNSSPropagatorBuilder` has therefore been completely revamped. It is now a specialization of
`AbstractAnalyticalPropagatorBuilder` and therefore implements the `PropagatorBuilder` API. All of
its original constructors and methods have been changed to match the interface API and superclass
constructors! the only thing that remains is its name and two private fields. There are no default
frames at all.

The `FieldGnssPropagatorBuilder` on the other hand was mimicked on `GNSSPropagatorBuilder`
but there are no equivalent `PropagatorBuilder`. The class was added with 13.0 for consistency
reasons, but these reasons are not relevant anymore and the class is not really useful. It was
therefore completely removed.

A side effect of the builders changes is that the `{Field}XxxAlmanac.getPropagator()` methods for
all supported satellites (Beidou, NavIC, GPS, QZSS, Galileo, civilian and legacy messages) now also
requires providing the inertial and body fixed frames.

### how to adapt existing source code

Users that used `GNSSPropagatorBuilder` must change all their uses. The single constructor requires
the inertial and body fixed frames to be set up at construction time, and these frames are now immutable,
so the corresponding setters have been removed. The setters for mass and attitude provider as well as
the propagator building method have all been renamed to match the `PropagatorBuilder` API.

Users that used `FieldGnssPropagatorBuilder` should directly build the `FieldGnssPropagator` by
themselves, there are no builder for that anymore.

Users that called `{Field}XxxAlmanac.getPropagator()` must now pass the inertial and body fixed frames
when creating the propagator.
